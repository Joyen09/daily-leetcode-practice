# 每日技術學習筆記 - 2025-03-18

## LeetCode 題目練習
- 題目編號: 1684
- 題目：[Find Latest Group of Size M](https://leetcode.com/problems/find-latest-group-of-size-m)
- 難度：Medium
- 相關標籤：Array, Hash Table, Binary Search, Simulation

## 題目描述
<p>Given an array <code>arr</code> that represents a permutation of numbers from <code>1</code> to <code>n</code>.</p>

<p>You have a binary string of size <code>n</code> that initially has all its bits set to zero. At each step <code>i</code> (assuming both the binary string and <code>arr</code> are 1-indexed) from <code>1</code> to <code>n</code>, the bit at position <code>arr[i]</code> is set to <code>1</code>.</p>

<p>You are also given an integer <code>m</code>. Find the latest step at which there exists a group of ones of length <code>m</code>. A group of ones is a contiguous substring of <code>1</code>&#39;s such that it cannot be extended in either direction.</p>

<p>Return <em>the latest step at which there exists a group of ones of length <strong>exactly</strong></em> <code>m</code>. <em>If no such group exists, return</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,5,1,2,4], m = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
Step 1: &quot;00<u>1</u>00&quot;, groups: [&quot;1&quot;]
Step 2: &quot;0010<u>1</u>&quot;, groups: [&quot;1&quot;, &quot;1&quot;]
Step 3: &quot;<u>1</u>0101&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]
Step 4: &quot;1<u>1</u>101&quot;, groups: [&quot;111&quot;, &quot;1&quot;]
Step 5: &quot;111<u>1</u>1&quot;, groups: [&quot;11111&quot;]
The latest step at which there exists a group of size 1 is step 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,5,4,2], m = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
Step 1: &quot;00<u>1</u>00&quot;, groups: [&quot;1&quot;]
Step 2: &quot;<u>1</u>0100&quot;, groups: [&quot;1&quot;, &quot;1&quot;]
Step 3: &quot;1010<u>1</u>&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]
Step 4: &quot;101<u>1</u>1&quot;, groups: [&quot;1&quot;, &quot;111&quot;]
Step 5: &quot;1<u>1</u>111&quot;, groups: [&quot;11111&quot;]
No group of size 2 exists during any step.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= n</code></li>
	<li>All integers in <code>arr</code> are <strong>distinct</strong>.</li>
</ul>


## 測試案例
```
[3,5,1,2,4]
1
```

## 建議解題思路
1. 理解問題需求：
   - 仔細閱讀題目要求
   - 分析輸入輸出格式
   - 注意邊界條件

2. 思考解決方案：
   - 考慮可能的演算法策略
   - 評估時間和空間複雜度
   - 選擇最佳解決方案

3. 實現步驟：
   - 先實現基本功能
   - 處理特殊情況
   - 優化程式碼

4. 測試驗證：
   - 使用題目提供的測試案例
   - 考慮極端情況
   - 驗證解決方案的正確性


### 解題程式碼
```python
class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        
```

### 學習重點
1. 使用的資料結構：
   - 
Array/List

2. 時間複雜度分析：
   - O(log n) - 二分搜尋的標準時間複雜度

3. 空間複雜度分析：
   - O(1) - 只使用常數額外空間

### 相關延伸學習
1. 相關演算法：
   - 
Array   - Binary Search   - Simulation   - Hash Table

2. 實際應用場景：
   - 
數據庫查詢優化   - 搜尋引擎實作   - 機器學習模型調參
